<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maybe a Week</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bayeszou.com/"/>
  <updated>2022-07-23T08:16:14.363Z</updated>
  <id>http://bayeszou.com/</id>
  
  <author>
    <name>1-WEEK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《东方梦符祭》有感</title>
    <link href="http://bayeszou.com/2018/12/30/%E4%B8%9C%E6%96%B9%E6%A2%A6%E7%AC%A6%E7%A5%AD%E6%9C%89%E6%84%9F/"/>
    <id>http://bayeszou.com/2018/12/30/东方梦符祭有感/</id>
    <published>2018-12-30T14:48:43.000Z</published>
    <updated>2022-07-23T08:16:14.363Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>Gotta knock a little harder<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="《Gotta knock a little harder》-山根麻以/菅野洋子 (如果你没听过，强烈推荐你听一遍；该曲来自于动画《Cowboy Bebop》，如果你没看过，也强烈推荐你看一遍）">[1]</span></a></sup></p></blockquote><span id="more"></span><p>地球倒数第二日下午，家乡初雪，约见几个好友，打上几盘游戏。磕磕碰碰（literally）奔波至网吧，可谓风雪无阻。</p><p>找个合适的项目不是件容易的事。成年之后的「游戏菜单」非常乏味，问题通常不来自于游戏，主要是人。「东方梦符祭<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[《东方梦符祭》](https://zh.wikipedia.org/wiki/%E4%B8%9C%E6%96%B9%E6%A2%A6%E7%AC%A6%E7%A5%AD)- dota2 中的一款自定义地图">[2]</span></a></sup>」.「塔防」，无论是名字还是类型，都属于一眼 pass 那种。不过接触一款游戏，往往也因为人。</p><p>简短的真人新手教学：</p><ol><li>游戏里的「式神」就是「塔」，具备「卡片」一样的性质，是游戏里主要的攻击手段，同时最多放置 12 个式神；</li><li>「式神」具备「卡片」一样的性质，大致有以下属性：<ol><li>品质：N, R, SR, SSR;</li><li>等级：1，2,…, 10;</li><li>星级：一星级，二星级，三星级，四星级，五星级</li></ol></li><li>「式神」的<strong>品质</strong>和其价格、稀有度相关（抽卡）；<strong>等级</strong>则是消灭单位获取，10 级封顶；<strong>星级</strong>表示强度，二星式神需要融合两张一星式神获取，三星式神需要融合三张二星式神获取，以此类推。</li></ol><p>好的游戏在开始段时间后，其体验和教材的课后习题一样──在你以为自己深谙规则的时候…… :D</p><p>滚雪球的劣势伴随突如其来的崩盘，迅速冲垮「防线」。幸运的是好友们在</p><blockquote><p>大量的低星式神前期中期可能有用，但是撑不过后期（第 50 波）的；主力至少应该有 1~2 个五星式神，剩下的仓位用于运营。</p><p>合理运营的话，第一个五星式神一般在 30 波的时候，构建好。</p></blockquote><p>所以这是个需要管理「库存」的游戏（存储用于生星的式神），加上个人体验，「运行」有部份程度的重复操作──类似于 2048。</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><blockquote><p>造出五星级式神的成本是多少？</p></blockquote><p>根据规则，五星式神需要 5 张四星式神融合，而一张四星式神…</p><p>可能因为最近开始看 SICP<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[*Structure and Interpretation of Computer Programs*](https://mitpress.mit.edu/sites/default/files/sicp/index.html)">[3]</span></a></sup> 的缘故，本能想到了递归：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">starNum</span>){</span><br><span class="line">  <span class="keyword">if</span>(starNum &gt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">count</span>(starNum - <span class="number">1</span>) * starNum</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>求 n 星需要多少张一星式神合成的函数，简单，易于理解，递推回归一目了然，但是有个问题：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 的空间复杂度，这种递归思想的写法有点浪费空间。</p><blockquote><p>有没有迭代的写法？</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params">starNum, cardNum</span>) {</span><br><span class="line">  <span class="keyword">if</span>(starNum===<span class="number">0</span>) <span class="keyword">return</span> cardNum</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">count</span>(starNum-<span class="number">1</span>, starNum*cardNum)</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.981ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 5737.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="mo" transform="translate(2418.8,0)"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g><g data-mml-node="mi" transform="translate(3696.6,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(4459.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(4848.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5348.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，和递归次数呈正比的空间复杂度，变成常数级。试着跑下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].<span class="title function_">map</span>(<span class="function"><span class="params">starNum</span>=&gt;</span><span class="title function_">count</span>(starNum))); <span class="comment">// [1, 2, 6, 24, 120]</span></span><br></pre></td></tr></table></figure><p>看到结果有些懵：所谓「计算 n 星卡成本」，只不过是算个阶乘 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.645ex" role="img" focusable="false" viewBox="0 -716 878 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(600,0)"><path data-c="21" d="M78 661Q78 682 96 699T138 716T180 700T199 661Q199 654 179 432T158 206Q156 198 139 198Q121 198 119 206Q118 209 98 431T78 661ZM79 61Q79 89 97 105T141 121Q164 119 181 104T198 61Q198 31 181 16T139 1Q114 1 97 16T79 61Z"></path></g></g></g></svg></mjx-container>。没发现什么有意思的问题，也没想出什么值得夸耀的答案。幻想和现实存在巨大落差，自我满足感来得快散得快。这基本也是今年一年的写照了，无论工作、学习还是情感方面。</p><p>每天都处于一种递归当中，365 次调用栈总结起来，也就是一年的成果。大概一生也不过几十年的递归而已。能不能迭代活着呢，将每日的收获传给下一日，每年的感悟递向新一年，这或许是种更积极更面向未来的生活方式吧（笑</p><p>这不是一篇活动记录，游戏攻略或测评，技术分享，更谈不上年终总结，反倒是今年第一篇正式意义上的 blog，总之</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>至地球 2018 倒数第一日以及 2019:</p><blockquote><p>Break though the door.<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="《Gotta knock a little harder》-山根麻以/菅野洋子 (如果你没听过，强烈推荐你听一遍；该曲来自于动画《Cowboy Bebop》，如果你没看过，也强烈推荐你看一遍）">[1]</span></a></sup></p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">《Gotta knock a little harder》-山根麻以/菅野洋子 (如果你没听过，强烈推荐你听一遍；该曲来自于动画《Cowboy Bebop》，如果你没看过，也强烈推荐你看一遍）<a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://zh.wikipedia.org/wiki/%E4%B8%9C%E6%96%B9%E6%A2%A6%E7%AC%A6%E7%A5%AD">《东方梦符祭》</a>- dota2 中的一款自定义地图<a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://mitpress.mit.edu/sites/default/files/sicp/index.html"><em>Structure and Interpretation of Computer Programs</em></a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Gotta knock a little harder&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; rel=&quot;footnote&quot;&gt;&lt;span class=&quot;hint--top-right hint--error hint--large&quot; aria-label=&quot;《Gotta knock a little harder》-山根麻以/菅野洋子 (如果你没听过，强烈推荐你听一遍；该曲来自于动画《Cowboy Bebop》，如果你没看过，也强烈推荐你看一遍）
&quot;&gt;[1]&lt;/span&gt;&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Router &amp; Route</title>
    <link href="http://bayeszou.com/2018/05/09/Router-Route/"/>
    <id>http://bayeszou.com/2018/05/09/Router-Route/</id>
    <published>2018-05-09T03:09:22.000Z</published>
    <updated>2018-05-09T03:20:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>英语水平拙劣..<code>Router</code> 和 <code>Route</code> 总是傻傻分不清。Google 之后，有了简短的新认识，记录一下：</p><blockquote><p>The <strong>router</strong> routes you to a route.</p></blockquote><p>&amp;</p><blockquote><p>Router (Component) is what makes the <strong>connection</strong> between browser location and the application.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://english.stackexchange.com/questions/182441/what-is-the-difference-between-router-and-route">What is the difference between “router” and “route”?</a></li><li><a href="https://stackoverflow.com/questions/43949554/what-is-the-different-between-router-vs-route-in-react-router-dom">What is the different between Router vs Route in react-router-dom</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;英语水平拙劣..&lt;code&gt;Router&lt;/code&gt; 和 &lt;code&gt;Ro
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件委托是如何工作的</title>
    <link href="http://bayeszou.com/2017/04/21/event-delegation/"/>
    <id>http://bayeszou.com/2017/04/21/event-delegation/</id>
    <published>2017-04-21T00:17:47.000Z</published>
    <updated>2018-05-09T03:10:09.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>假如在一个 <code>ul</code> 中有着 100 个 <code>li</code>，当鼠标点击一个 <code>li</code> 的时候，便执行一些动作。完成以上功能必须给每个 <code>li</code> 都绑定一个事件吗？显然这么做有点浪费，毕竟要绑定 100 次，倘若能只绑定一次，就好了——说得便是<strong>事件委托</strong>。</p><span id="more"></span><p>事件委托（Event Delegation）是 JavaScript 中十分常用的方法之一。事件委托允许你不监听那些具体（<code>li</code>）的元素，相应的把事件绑定在其父元素（<code>ul</code>)上。例如下面这段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;parent-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如之前所说，分别给每个 <code>li</code> 的绑定事件，不仅看上去有些浪费，而且一旦再添加新的 <code>li</code> 的时候，还要再给新加入的元素绑定事件，没法实现动态监听。但是父元素 <code>ul</code> 是不变的，给它绑定监听事件再合适不过。</p><p>关键问题是：怎么找到那个<strong>目标元素</strong>？请看下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到父元素，给其绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent-list&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">//找到真正的目标元素</span></span><br><span class="line">  <span class="keyword">if</span>(e.<span class="property">target</span> &amp;&amp; e.<span class="property">target</span>.<span class="property">nodeName</span> === <span class="string">&quot;LI&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">target</span>.<span class="property">innerText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>监听 <code>ul</code>，一旦子元素事件冒泡到父元素，通过 event.target 检查是否找到了目标元素。如果没找到，就忽略这次事件；找到了，则输出目标元素内容。可以点击示例查看结果：</p><p><a class="jsbin-embed" href="http://jsbin.com/vexeter/embed?console,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.41.10"></script></p><p>这只是简单的使用原生 JS 实现事件委托，其中还有许多不足——如果 <code>li</code> 内还有子元素怎么办？</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;parent-list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span>Item 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>情况有两点不同：</p><ol><li>虽然点击的元素时  <code>li.child li</code>，但实际的目标元素为 <code>li.child</code> </li><li>需要判断点击的元素是否在 <code>li.child</code> 之内</li></ol><p>对于第一点，使用 <code>Element.matches()</code> 或许会是个好主意<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="较新的浏览器才支持 `Element.matches()`，可能会有兼容性的问题。">[1]</span></a></sup>。第二点的解决办法是：循环检查点击元素的父元素，止于监听元素。如下示例：</p><p><a class="jsbin-embed" href="http://jsbin.com/sedewet/embed?console,output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.41.10"></script></p><p>当然，还有许多 DOM 库在处理事件和元素时，有着更强大的功能，在实际应用中也很有帮助。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://davidwalsh.name/event-delegate">How JavaScript Event Delegation Works</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">较新的浏览器才支持 <code>Element.matches()</code>，可能会有兼容性的问题。<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假如在一个 &lt;code&gt;ul&lt;/code&gt; 中有着 100 个 &lt;code&gt;li&lt;/code&gt;，当鼠标点击一个 &lt;code&gt;li&lt;/code&gt; 的时候，便执行一些动作。完成以上功能必须给每个 &lt;code&gt;li&lt;/code&gt; 都绑定一个事件吗？显然这么做有点浪费，毕竟要绑定 100 次，倘若能只绑定一次，就好了——说得便是&lt;strong&gt;事件委托&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初识 DOM 及些许感性理解</title>
    <link href="http://bayeszou.com/2017/04/17/%E5%88%9D%E8%AF%86-DOM-%E5%8F%8A%E4%BA%9B%E8%AE%B8%E6%84%9F%E6%80%A7%E7%90%86%E8%A7%A3/"/>
    <id>http://bayeszou.com/2017/04/17/初识-DOM-及些许感性理解/</id>
    <published>2017-04-17T14:23:26.000Z</published>
    <updated>2017-04-17T14:23:49.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>学完 JavaScript，还在疑惑其作用的时候，DOM 蹦了出来。有些不知所云，几番查阅只有，意识到自己有着不少误解，将新的理解总结出来，以供之后再来审视。</p><h2 id="DOM-vs-HTML"><a href="#DOM-vs-HTML" class="headerlink" title="DOM vs HTML"></a>DOM vs HTML</h2><p>DOM 是什么，在哪能看到 DOM 吗？使用浏览器阅读网页的时候，按 <kbd>f12</kbd> 打开开发者工具，你会看到这样的画面</p><p><img src="http://on9uavm7d.bkt.clouddn.com/2017-04-17-14924361569234.jpg" alt=""></p><p>标注的部分，就是常常听说的 DOM 了。</p><p>看上去，这个我们写的 HTML 似乎一样呀。</p><p><img src="http://on9uavm7d.bkt.clouddn.com/2017-04-17-14924358992550.jpg" alt=""></p><p>如果再研究研究，就能发现，两者还是有些区别的。下面是对 DOM 进行了操作的结果。</p><p><img src="http://on9uavm7d.bkt.clouddn.com/2017-04-17-14924358708050.jpg" alt=""></p><h2 id="DOM-vs-JS"><a href="#DOM-vs-JS" class="headerlink" title="DOM vs JS"></a>DOM vs JS</h2><ul><li>1993 年，HTML 发布</li><li>1996 年，JavaScript 发布</li><li>1996 年，CSS 发布</li><li>1998 年，XML 发布</li></ul><p>时间先暂停在 1998 年以前，现在人们有了 HTML 表达文档的内容，CSS 描述文档的样式，也有了 JavaScript，但当时并没有 DOM 标准。这意味着，例如 <code>.addEventListener</code> 之类的方法无法使用。也就是说，怎么「操作」文档，这不是 JavaScript<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="全文提及的 JavaScript 都指的是语言本身，而非局限于网页或其他宿主环境">[1]</span></a></sup> 的范畴！</p><p>换言之，之前认为 <code>.addEventListener</code> 是 JavaScript 的东西，实则 DOM 定义的 API。</p><p>回到 1998 年前，当时怎么使用 JS 操作文档，是没有统一的规范的——一切取决于浏览器，各家厂商都有自己的定义方式——非标准性质的 DOM 出现。然后 IE4 和 Netscape Navigator 4 又各自退出了自己的 DOM 扩展，增强 JavaScript 的功能，也称为 Dynamic HTML（简称 DHTML）。这段时期的 “DOM”，习惯上也成为 DOM Level 0, 是历史中的一个参考点，而非正式的标准规范。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><h3 id="DOM-Level-1"><a href="#DOM-Level-1" class="headerlink" title="DOM Level 1"></a>DOM Level 1</h3><ul><li>1998 年，DOM Level 1 发布</li></ul><p>W3C 正式发布了 DOM，名为 DOM Level 1，主要为了映射文档结构，由两块组成：</p><ul><li>Core：映射以 XML 为基础的文档结构</li><li>HTML：基于 Core 进行了扩展，添加针对 HTML 的对象和方法</li></ul><h3 id="DOM-Level-2"><a href="#DOM-Level-2" class="headerlink" title="DOM Level 2"></a>DOM Level 2</h3><ul><li>2000~2003 年，DOM Level 2 发布</li></ul><p>2 级 DOM 对之前的 Core 进行了拓展，支持了 XML 的命名空间，而且引入了更多的模块：</p><ul><li>Views：描述跟踪一个文档的各种视图（使用 CSS 样式设计文档前后）的接口</li><li>Event：描述事件接口</li><li>Style：描述处理基于 CSS 样式的接口</li><li>Traversal and Range：描述遍历和操作文档树的接口</li></ul><h3 id="DOM-Level-3"><a href="#DOM-Level-3" class="headerlink" title="DOM Level 3"></a>DOM Level 3</h3><ul><li>2003~2004 年，DOM Level 3 发布</li></ul><p>此时，新引入了两者模块:</p><ul><li>Load and Save：统一方式加载和保存文档的方法</li><li>Validation：描述了验证文档的方法</li></ul><p>对 Core 再次进行了拓展，支持 XML 1.0 规范，涉及 XML Infoset、XPath 和 XML Base。</p><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>截止 2017-04-17，DOM Level 4 还在草稿阶段。现在再来看看 MDN 上关于 DOM 的描述：</p><blockquote><p>文档对象模型 (DOM) 是 HTML 和 XML 文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将 web 页面和脚本或程序语言连接起来。</p></blockquote><p>所以</p><ul><li>只有 JavaScript 才能操作 DOM 吗？W3C 的标准里没有规定，任何语言都可以。</li><li>有 JavaScript 就一定有 DOM 吗？并不是，可以在浏览器和 Node.js 中分别执行 <code>console.log(document)</code> 试试。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>同时推荐点击链接，可以更深入了解 DOM</p><ul><li>W3C: <a href="http://www.w3.org/TR/DOM-Level-2-Core/introduction.html">What is the Document Object Model?</a> &amp; <a href="https://www.w3.org/DOM/DOMTR">Document Object Model (DOM) Technical Reports</a></li><li>MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document_Object_Model/Introduction">DOM 概述</a></li><li><a href="https://github.com/jawil/blog/issues/9">深入浅出 DOM 基础——《DOM 探索之基础详解篇》学习笔记</a></li><li><a href="https://css-tricks.com/dom/">What is the DOM?</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;">全文提及的 JavaScript 都指的是语言本身，而非局限于网页或其他宿主环境<a href="#fnref:1" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;学完 JavaScript，还在疑惑其作用的时候，DOM 蹦了出来。有些不知
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用 CSS 居中对齐</title>
    <link href="http://bayeszou.com/2017/03/23/%E5%88%A9%E7%94%A8%20CSS%20%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90/"/>
    <id>http://bayeszou.com/2017/03/23/利用 CSS 居中对齐/</id>
    <published>2017-03-23T02:54:00.000Z</published>
    <updated>2017-03-23T12:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>CSS 居中的方法实在是太多啦，每次光靠 Google 去搜都要费好大力气。看了 <a href="https://css-tricks.com/centering-css-complete-guide/">Centering in CSS: A Complete Guide</a> 才清楚了许多，对自己的认识做个总结。</p><span id="more"></span><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="inline-和-inline-元素"><a href="#inline-和-inline-元素" class="headerlink" title="inline 和 inline-* 元素"></a>inline 和 inline-* 元素</h3><p>在一个 block-level 中的 <code>inline</code>, <code>inline-block</code>, <code>inline-table</code>, <code>inline-flex</code> 元素，居中只需要一行：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center-children</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block-level-元素"><a href="#block-level-元素" class="headerlink" title="block-level 元素"></a>block-level 元素</h3><p>将左右的 <code>margin</code> 设置升 <code>auto</code> 就可以让一个 block-level 元素居中，常常见到这种写法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简写虽然方便，但是如果不希望上下 <code>margin</code> 设置为 0，此写法就会带来副作用。分别设置会更安全些：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">margin-left</span>:  auto;</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="至少两个的-block-level-元素"><a href="#至少两个的-block-level-元素" class="headerlink" title="至少两个的 block-level 元素"></a>至少两个的 block-level 元素</h3><p>多个 block-level 的元素在居中在一行，需要将 <code>display: block</code> 改为 <code>display: inline-block</code> 然后设置其父元素的 <code>text-align</code>，具体见下样例：</p><p><a class="jsbin-embed" href="http://jsbin.com/zutimo/embed?output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script></p><p>或者，你也可以使用 flexbox 呀~ 这个稍后说。</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><p>垂直居中会稍微麻烦一丢</p><h3 id="inline-和-inline-元素-1"><a href="#inline-和-inline-元素-1" class="headerlink" title="inline 和 inline-* 元素"></a>inline 和 inline-* 元素</h3><p>有一个简单粗暴的方法：直接设置上下 <code>padding</code> 相等。不过有时候，这个方法不是那么有效。</p><h4 id="只有一行"><a href="#只有一行" class="headerlink" title="只有一行"></a>只有一行</h4><p>因为只有一行，所以能设置 <code>line-height</code> 和 <code>height</code> 相等完成居中。</p><h4 id="存在多行"><a href="#存在多行" class="headerlink" title="存在多行"></a>存在多行</h4><p>如果是自己设置的 <code>table-cell</code> 元素，需要设置 <code>vertical-align: middle;</code> 完成居中。在 <code>td</code> 这项属性值是默认的，不要设置。详见样例：</p><p><a class="jsbin-embed" href="http://jsbin.com/kawido/embed?output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script></p><p>巧了，你也可以使用 flexbox 呀~ 这个稍后再说。</p><h3 id="一个-block-level-元素"><a href="#一个-block-level-元素" class="headerlink" title="一个 block-level 元素"></a>一个 block-level 元素</h3><p>有些时候我们未必会知道 block-level 元素的高度，这取决于其内部放置的元素。如果不用 flexbox 的话，需要分情况讨论：</p><h4 id="已知高度"><a href="#已知高度" class="headerlink" title="已知高度"></a>已知高度</h4><p>已知高度的话，先学会算数，再学会定位，用样例说话：</p><p><a class="jsbin-embed" href="http://jsbin.com/kunami/embed?output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script></p><h4 id="未知高度"><a href="#未知高度" class="headerlink" title="未知高度"></a>未知高度</h4><p>未知也没关系，设置 <code>top: 50%</code>，这样元素的顶部就处于父元素正中间，再让其向上平移自身 50%（<code>transform: translateY(-50%);</code>）的高度，其内容就居中了。可以自己编辑样例试试：</p><p><a class="jsbin-embed" href="http://jsbin.com/wirekot/embed?output">JS Bin on jsbin.com</a><script src="http://static.jsbin.com/js/embed.min.js?3.35.5"></script></p><p>当然，你也可以使用 flexbox 呀~ 这个还是稍后再说。</p><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>可以通过以上方法的组合按自己喜欢的方式完成水平居中。其中通过定位对各个浏览器都比较友好，水平居中直接设置 <code>top: 50%; left: 50%;</code>；垂直居中按照「已知高度」和「未知高度」的思路区分实现，注意在「未知高度」时还要兼顾 x 方向平移 50%（即 <code>transform: translate(-50%, -50%)</code>）。</p><h2 id="使用-flexbox"><a href="#使用-flexbox" class="headerlink" title="使用 flexbox!!!"></a>使用 flexbox!!!</h2><p>如果不需要考虑部分老旧浏览器的兼容问题，那么 flexbox 则是万能了。强烈推荐学习并使用 flexbox，会省下不少功夫！怎么学习？<a href="http://flexboxfroggy.com/#zh-cn">青蛙</a>会告诉你~</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这里说得所有<strong>居中</strong>，都是<strong>浏览器</strong>认为的<strong>居中</strong>，有时与<strong>人类眼中的居中</strong>，是<strong>不同</strong>的。例如，将单行内容为 <code>。。。</code> 的文字按以上任一方法垂直居中，其显示效果是偏下的。原因归根于，我们看到的文字是基于像素的，浏览器看到的文字是基于当前选用的字体信息，可以通过这篇<a href="http://iamvdo.me/en/blog/css-font-metrics-line-height-and-vertical-align">文章</a>（或其<a href="https://zhuanlan.zhihu.com/p/25808995?group_id=825729871287291904">译文</a>）了解大概。对于文字，浏览器认为的居中未必是像素居中。所以，某个大字标题在网页中的居中效果和设计稿中不同时，不要太惊讶。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://css-tricks.com/centering-css-complete-guide/">Centering in CSS: A Complete Guide</a></li><li><a href="https://zhanglun.github.io/2014/09/30/css%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD%E5%AF%B9%E9%BD%90%E5%A4%A7%E6%B3%95/">CSS 元素居中对齐大法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CSS 居中的方法实在是太多啦，每次光靠 Google 去搜都要费好大力气。看了 &lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot;&gt;Centering in CSS: A Complete Guide&lt;/a&gt; 才清楚了许多，对自己的认识做个总结。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>对 meta 的初步认识</title>
    <link href="http://bayeszou.com/2017/03/14/%E5%AF%B9%20%3Cmeta%3E%20%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/"/>
    <id>http://bayeszou.com/2017/03/14/对 &lt;meta&gt; 的初步认识/</id>
    <published>2017-03-14T01:57:00.000Z</published>
    <updated>2017-03-23T12:56:12.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>在 <a href="https://www.coursera.org">Coursera</a> 学习 <a href="https://www.coursera.org/learn/html-css-javascript-for-web-developers/home">HTML CSS JavaScript for Web Developers</a> 的时候，有讲如果要让网页在移动设备上更好的显示，需要在 HTML 中的 <code>&lt;head&gt;</code> 里加上这一行代码：</p><span id="more"></span><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 Hexo 在搭建博客时也发现了类似的内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;generator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Bayestheorem&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Bayes Zou&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;BayesZ&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当时并没有太在意 <code>&lt;meta&gt;</code> 的作用，认为不过是一些「约定好的声明」罢了。然后听方老师的课知道了 Github 上的这个项目<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[GitHub HEAD](https://github.com/joshbuchea/HEAD)">[1]</span></a></sup>，感觉这才第一次认识了这个元素。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>借用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">MDN</a> 的描述：</p><blockquote><p>The <strong>HTML</strong> <code>&lt;meta&gt;</code> <strong>element</strong> represents any metadata information that cannot be represented by one of the other HTML meta-related elements. (<code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> or <code>&lt;title&gt;</code>).</p></blockquote><p><code>&lt;meta&gt;</code> 元素表示所有不能被其他 HTML 元相关元素（如 <code>&lt;base&gt;</code>, <code>&lt;link&gt;</code>, <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code> or <code>&lt;title&gt;</code>）表示的元信息。</p><p><code>&lt;meta&gt;</code> 里的信息不会显示在页面上，因为这不是给用户看的，而是提供给机器的信息。</p><p><code>&lt;meta&gt;</code> 不该写成 <code>&lt;meta/&gt;</code>。</p><p> <code>&lt;meta&gt;</code> 元素有两个属性（attribute），<code>http-equiv</code> 和 <code>name</code> 属性，以及和属性对应的属性值（content）。有兴趣了解详细信息的可以自行查阅<sup id="fnref:2"><a href="#fn:2" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[HTML 标准规范](https://www.w3.org/TR/html5/document-metadata.html#the-meta-element)、[MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta) 及 Lxxyx 的[文章](https://segmentfault.com/a/1190000004279791)">[2]</span></a></sup>，这里主要想总结下自己所理解的 <code>&lt;meta&gt;</code> 元素能做什么，和一点相关思考。</p><h2 id="能做的"><a href="#能做的" class="headerlink" title="能做的"></a>能做的</h2><h3 id="关于浏览器"><a href="#关于浏览器" class="headerlink" title="关于浏览器"></a>关于浏览器</h3><ul><li>这么元信息可以被用于让浏览器知道网页的<strong>编码</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>让浏览器知道测采取哪种版本<strong>渲染</strong>页面：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-ua-compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>或者根据国情选择<strong>浏览器的内核</strong>：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit|ie-comp|ie-stand&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 iPhone 上伪装成一个离线 app：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>控制页面在本地的<strong>缓存</strong>，若禁止，则用户将无法离线访问：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Expires&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Pragma&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Cache-Control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no-cache&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>还有许多作用，例如开头提及的优化移动端的显示，站点适配等等。</p><h3 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h3><ul><li>描述页面，可以概括网页的大致内容：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your words&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加关键词，让用户搜索相关关键字或短语时，更容易找到符合要求的网页：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keyword&quot;</span> <span class="attr">content</span>=<span class="string">&quot;your tags&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>以及页面重定向：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了以上，和可以声明<strong>网页作者</strong>，设置搜索<strong>引擎索引方式</strong>，标注<strong>版权</strong>信息等等。</p><h2 id="相关思考"><a href="#相关思考" class="headerlink" title="相关思考"></a>相关思考</h2><h3 id="的位置"><a href="#的位置" class="headerlink" title=" 的位置"></a><meta> 的位置</h3><p>在查阅关于 <code>&lt;meta&gt;</code> 信息的过程中看到这样一个回答：</p><blockquote><p>…叫头标签，需要写在 meta 内部最前面，在它之前你唯一能写的只有 “title”, 其他都不可以。</p></blockquote><p>关于 <code>&lt;meta&gt;</code> 在 <code>&lt;head&gt;</code> 中的位置，规范中似乎没有找到要求。经搜索发现贺老在知乎的答案<sup id="fnref:3"><a href="#fn:3" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[前端规范，HTML 的 `<head>` 标签内 `<meta>`、`<title>` 等标签顺序是怎样的?](https://www.zhihu.com/question/28714116/answer/41830759)">[3]</span></a></sup>：</p><blockquote><p>没有特定规定。<br>不过我至少有一条建议：确保 <code>&lt;meta charset=encoding&gt;</code> 放在最前，让浏览器尽早获得字符编码信息，如果要浏览器据此决定转码可以早点转。</p></blockquote><h3 id="越来越长的"><a href="#越来越长的" class="headerlink" title="越来越长的 "></a>越来越长的 <head></h3><p>看到 HEAD<sup id="fnref:1"><a href="#fn:1" rel="footnote"><span class="hint--top-right hint--error hint--large" aria-label="[GitHub HEAD](https://github.com/joshbuchea/HEAD)">[1]</span></a></sup> 的时候，本能有两个反应：</p><blockquote><p>天啊，靠 <code>&lt;head&gt;</code> 原来能做这么多事？！😳</p></blockquote><p>以及</p><blockquote><p>天啊，原来这么多平台都各自靠 <code>&lt;head&gt;</code> 做这么多事？！☹️</p></blockquote><p>有些 <code>&lt;meta&gt;</code> &amp; <code>&lt;link&gt;</code> 定义重复，但是为了兼容不同私有平台的「私货」，使 <code>&lt;head&gt;</code> 被越塞越满，尤其一些 Web App：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;144x144&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/touch/apple-touch-icon-144x144-precomposed.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;114x114&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/touch/apple-touch-icon-114x114-precomposed.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">sizes</span>=<span class="string">&quot;72x72&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/touch/apple-touch-icon-72x72-precomposed.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/touch/apple-touch-icon-57x57-precomposed.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;black&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Lighten&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mate</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>W3C WebApps 工作组指定的 <a href="https://www.w3.org/TR/appmanifest/">W3C Web App Manifest</a> 不失为一种好的解决办法。或许在将来，不停加 <code>&lt;meta&gt;</code>/<code>&lt;link&gt;</code> 的做法会被使用 JSON 代替。</p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><a href="https://segmentfault.com/a/1190000002407912">常用 meta 整理</a></li><li><a href="https://huangxuan.me/2017/02/09/nextgen-web-pwa/#Web App Manifest">下一代 Web 应用模型 —— Progressive Web App</a></li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style: none; padding-left: 0; margin-left: 40px"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">1.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://github.com/joshbuchea/HEAD">GitHub HEAD</a><a href="#fnref:1" rev="footnote"> ↩</a></span></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">2.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.w3.org/TR/html5/document-metadata.html#the-meta-element">HTML 标准规范</a>、<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta">MDN</a> 及 Lxxyx 的<a href="https://segmentfault.com/a/1190000004279791">文章</a><a href="#fnref:2" rev="footnote"> ↩</a></span></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px; margin-left: -40px">3.</span><span style="display: inline-block; vertical-align: top; margin-left: 10px;"><a href="https://www.zhihu.com/question/28714116/answer/41830759">前端规范，HTML 的 <code>&lt;head&gt;</code> 标签内 <code>&lt;meta&gt;</code>、<code>&lt;title&gt;</code> 等标签顺序是怎样的?</a><a href="#fnref:3" rev="footnote"> ↩</a></span></li></ol></div></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;a href=&quot;https://www.coursera.org&quot;&gt;Coursera&lt;/a&gt; 学习 &lt;a href=&quot;https://www.coursera.org/learn/html-css-javascript-for-web-developers/home&quot;&gt;HTML CSS JavaScript for Web Developers&lt;/a&gt; 的时候，有讲如果要让网页在移动设备上更好的显示，需要在 HTML 中的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 里加上这一行代码：&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2015 年末的资格</title>
    <link href="http://bayeszou.com/2015/12/31/2015%20%E5%B9%B4%E6%9C%AB%E7%9A%84%E8%B5%84%E6%A0%BC/"/>
    <id>http://bayeszou.com/2015/12/31/2015 年末的资格/</id>
    <published>2015-12-31T10:00:00.000Z</published>
    <updated>2017-03-23T06:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>见完老友，听着钟爱的声音，静静思考。几个月来，还不够成了对自己资格的评价。</p><span id="more"></span><p>年末，无需纠结于资格，多点对未来的愿景。</p><p>引用木遥老师对于博客的<a href="http://blog.farmostwood.net/351.html">想法</a> :)</p><blockquote><p>我们彼此谈论也互相倾听并且乐此不疲，不是因为我们有曝露和窥探的癖好，而只是为了从别人身上看到更多的自己。我们要知道我们不是孤独的，还有人愿意首肯我们的坚持，了解我们的努力，期待我们的进步。那不只是记录生活的方式而已，而是生活本身的一部分。在这个过程中，在这些文字的觥筹交错之间，我们得以定义自己的存在，触碰彼此的温暖——以及更重要的，看见我们的未来。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;见完老友，听着钟爱的声音，静静思考。几个月来，还不够成了对自己资格的评价。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
